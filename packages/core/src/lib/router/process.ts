import {
  ActivatedRouteSnapshot,
  DefaultExport,
  provideRouter as provideNgRouter,
  Route as NgRoute,
  RouterFeatures,
  RouterStateSnapshot,
  Routes as NgRoutes,
  UrlSegment,
} from '@angular/router';
import { EnvironmentProviders } from '@angular/core';
import { Observable } from 'rxjs';
import { ClassType, isClass } from '@deepkit/core';
import {
  reflect,
  ReflectionKind,
  TypeClass,
  TypeFunction,
} from '@deepkit/type';

import {
  AppModule,
  createModule,
  createStandaloneComponentModule,
  ServiceContainer,
} from '../injector';
import { ResolveFn, Route, Routes } from './types';
import { Injector } from '@deepkit/injector';

function isWrappedDefaultExport<T>(
  value: T | DefaultExport<T>,
): value is DefaultExport<T> {
  // We use `in` here with a string key `'default'`, because we expect `DefaultExport` objects to be
  // dynamically imported ES modules with a spec-mandated `default` key. Thus we don't expect that
  // `default` will be a renamed property.
  return value && typeof value === 'object' && 'default' in value;
}

function maybeUnwrapDefaultExport<T>(input: T | DefaultExport<T>): T {
  // As per `isWrappedDefaultExport`, the `default` key here is generated by the browser and not
  // subject to property renaming, so we reference it with bracket access.
  return isWrappedDefaultExport(input) ? input['default'] : input;
}

export interface ParentRouteData {
  readonly module: RouteModule;
  readonly route: Route;
}

export class RouteModule extends createModule({
  providers: [
    // FIXME: CircularDependencyError: Circular dependency found  -> ActivatedRouteSnapshot ->
    // provideNgDependency(ActivatedRouteSnapshot),
    // FIXME: CircularDependencyError: Circular dependency found  -> RouterStateSnapshot ->
    // provideNgDependency(RouterStateSnapshot),
  ],
}) {
  readonly children = new Set<RouteModule>();

  constructor(
    readonly current: Route,
    parent?: ParentRouteData,
  ) {
    super();
    this.name = current.path || 'index';
    if (current.providers) {
      this.addProvider(...current.providers);
    }
    if (current.imports) {
      this.addImport(...current.imports);
    }
    if (parent) {
      this.setParent(parent.module);
      parent.module.addChild(this);
    }
  }

  addChild(module: RouteModule): void {
    this.children.add(module);
  }
}

function processRouteGuards(module: RouteModule, route: Route) {
  if (route.canActivate) {
    route.canActivate = route.canActivate.map(canActivate => {
      if (isClass(canActivate)) {
        if (!module.isProvided(canActivate)) {
          module.addProvider(canActivate);
        }
        return (route: ActivatedRouteSnapshot, state: RouterStateSnapshot) => {
          const guard = module.injector!.get(canActivate);
          return guard.canActivate(route, state);
        };
      }

      return resolveRouteFunction(module, canActivate);
    });
  }

  if (route.canActivateChild) {
    route.canActivateChild = route.canActivateChild.map(canActivateChild => {
      if (isClass(canActivateChild)) {
        if (!module.isProvided(canActivateChild)) {
          module.addProvider(canActivateChild);
        }
        return (route: ActivatedRouteSnapshot, state: RouterStateSnapshot) => {
          const guard = module.injector!.get(canActivateChild);
          return guard.canActivateChild(route, state);
        };
      }

      return resolveRouteFunction(module, canActivateChild);
    });
  }

  if (route.canDeactivate) {
    route.canDeactivate = route.canDeactivate.map(canDeactivate => {
      if (isClass(canDeactivate)) {
        if (!module.isProvided(canDeactivate)) {
          module.addProvider(canDeactivate);
        }
        return (
          component: unknown,
          currentRoute: ActivatedRouteSnapshot,
          currentState: RouterStateSnapshot,
          nextState: RouterStateSnapshot,
        ) => {
          const guard = module.injector!.get(canDeactivate);
          return guard.canDeactivate(
            component,
            currentRoute,
            currentState,
            nextState,
          );
        };
      }

      return resolveRouteFunction(module, canDeactivate);
    });
  }

  if (route.canMatch) {
    route.canMatch = route.canMatch.map(canMatch => {
      if (isClass(canMatch)) {
        if (!module.isProvided(canMatch)) {
          module.addProvider(canMatch);
        }
        // FIXME: Route not supported in resolveRouteFunction deps
        return (route: Route, segments: UrlSegment[]) => {
          const guard = module.injector!.get(canMatch);
          return guard.canMatch(route, segments);
        };
      }

      return resolveRouteFunction(module, canMatch);
    });
  }
}

function processRouteResolvers(module: RouteModule, route: Route) {
  if (route.resolve) {
    for (const [key, resolve] of Object.entries(route.resolve)) {
      const ngResolve = route.resolve as Record<string, ResolveFn<unknown>>;
      if (isClass(resolve)) {
        module.addProvider(resolve);

        ngResolve[key] = (
          route: ActivatedRouteSnapshot,
          state: RouterStateSnapshot,
        ) => {
          const resolver = module.injector!.get(resolve);
          return resolver.resolve(route, state);
        };
      } else {
        // module.addProvider({
        //   provide: resolve,
        //   transient: true,
        //   useFactory: resolve,
        // });
        ngResolve[key] = resolveRouteFunction(module, resolve);
      }
    }
  }
}

function processRouteChildren(module: RouteModule, route: Route) {
  if (typeof route.loadChildren === 'function') {
    const routeLoadChildren = route.loadChildren;
    route.loadChildren = async () => {
      const mod = await routeLoadChildren();
      const routes = maybeUnwrapDefaultExport(
        await (mod instanceof Observable ? mod.toPromise() : mod),
      );
      if (!Array.isArray(routes)) {
        throw new Error('Only an array of routes are supported');
      }
      for (const nextRoute of routes) {
        processRoute(nextRoute as Route, { route, module });
      }
      return routes;
    };
  } else if (route.children) {
    for (const childRoute of route.children) {
      processRoute(childRoute as Route, { route, module });
    }
  }
}

export function processRoute(route: Route, parent?: ParentRouteData): NgRoute {
  const module = new RouteModule(route, parent);
  const serviceContainer = new ServiceContainer(module);

  processRouteChildren(module, route);

  processRouteGuards(module, route);

  processRouteResolvers(module, route);

  function processComponent(component: ClassType) {
    const componentModule = createStandaloneComponentModule(component);
    module.addImport(componentModule);
    serviceContainer.process();
  }

  if (route.component) {
    processComponent(route.component);
  } else if (typeof route.loadComponent === 'function') {
    const routeLoadComponent = route.loadComponent;
    route.loadComponent = async () => {
      const mod = await routeLoadComponent();
      const component = maybeUnwrapDefaultExport(
        await (mod instanceof Observable ? mod.toPromise() : mod),
      );
      if (!component) {
        throw new Error('Missing component');
      }
      processComponent(component);
      return component;
    };
  }

  return route as NgRoute;
}

function resolveFunctionWithCustomClassTypeDependencies<
  Fn extends (...args: any) => any,
>(injector: Injector, fn: Fn, deps: WeakMap<ClassType, any>): ReturnType<Fn> {
  const fnType = reflect(fn) as TypeFunction;
  const args = fnType.parameters.map(parameter => {
    if (
      parameter.type.kind === ReflectionKind.class &&
      deps.has(parameter.type.classType)
    ) {
      return deps.get(parameter.type.classType);
    }
    return injector.get(parameter.type);
  });
  return fn(...args);
}

function resolveRouteFunction<Fn extends (...args: any) => any>(
  module: AppModule,
  fn: Fn,
): (...args: any[]) => ReturnType<Fn> {
  const fnType = reflect(fn) as TypeFunction;
  return (...deps: any[]) => {
    const args = fnType.parameters.map(parameter => {
      const classDependency =
        parameter.type.kind === ReflectionKind.class &&
        deps.find(
          dep => dep instanceof (parameter.type as TypeClass).classType,
        );
      // const interfaceDependency = parameter.type.kind === ReflectionKind.objectLiteral && deps.find(dep => dep === parameter.type.typeName)
      return classDependency || module.injector!.get(parameter.type);
    });
    return fn(...args);
  };
}

export function provideRouter(
  routes: Routes,
  ...features: RouterFeatures[]
): EnvironmentProviders {
  for (const route of routes) {
    processRoute(route);
  }
  return provideNgRouter(routes as NgRoutes, ...features);
}
