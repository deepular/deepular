import {
  DefaultExport,
  provideRouter,
  Routes as NgRoutes,
  Route as NgRoute,
  ResolveFn as NgResolveFn,
  ActivatedRouteSnapshot, RouterStateSnapshot,
} from '@angular/router';
import { ApplicationConfig } from '@angular/core';
import { Observable } from 'rxjs';
import { ClassType, isClass } from '@deepkit/core';

import {
  createModule,
  createStandaloneComponentModule, provideNgDependency,
  ServiceContainer,
} from '../injector';
import { Route, Routes } from './types';

function isWrappedDefaultExport<T>(value: T|DefaultExport<T>): value is DefaultExport<T> {
  // We use `in` here with a string key `'default'`, because we expect `DefaultExport` objects to be
  // dynamically imported ES modules with a spec-mandated `default` key. Thus we don't expect that
  // `default` will be a renamed property.
  return value && typeof value === 'object' && 'default' in value;
}

function maybeUnwrapDefaultExport<T>(input: T|DefaultExport<T>): T {
  // As per `isWrappedDefaultExport`, the `default` key here is generated by the browser and not
  // subject to property renaming, so we reference it with bracket access.
  return isWrappedDefaultExport(input) ? input['default'] : input;
}

function createServiceContainer(route: Route): ServiceContainer {
  const routeModule = new (class extends createModule({}, `Route<${route.path}>`){});
  return new ServiceContainer(routeModule);
}

export function processRoute(route: Route, serviceContainer: ServiceContainer, parent?: Route): Route {
  const routeModule = new (class extends createModule({}, `Route<${route.path}>`){});
  serviceContainer.appModule.addImport(routeModule);

  if (typeof route.loadChildren === 'function') {
    const routeLoadChildren = route.loadChildren;
    route.loadChildren = async () => {
      const mod =  await routeLoadChildren();
      const routes = maybeUnwrapDefaultExport(await (mod instanceof Observable ? mod.toPromise() : mod));
      if (!Array.isArray(routes)) {
        throw new Error('Only an array of routes are supported');
      }
      const serviceContainer = createServiceContainer(route);
      for (const route of routes) {
        processRoute(route, serviceContainer);
      }
      serviceContainer.process();
      return routes;
    };
  } else if (route.children) {
    for (const childRoute of route.children) {
      processRoute(childRoute, serviceContainer, route);
    }
  }

  if (route.resolve) {
    const ngResolve: Record<string, NgResolveFn<unknown>> = {};
    for (const [key, resolve] of Object.entries(route.resolve)) {
      if (isClass(resolve)) {
        routeModule.addProvider({
          provide: resolve,
          useClass: resolve as ClassType,
        });

        ngResolve[key] = (route, state) => {
          const resolver = routeModule.injector!.get(resolve);
          return resolver.resolve(route, state);
        };
      } else {
        routeModule.addProvider({
          provide: resolve,
          useFactory: resolve,
        });

        routeModule.addProvider(
          provideNgDependency(ActivatedRouteSnapshot),
          provideNgDependency(RouterStateSnapshot),
        );

        ngResolve[key] = () => routeModule.injector!.get(resolve);
      }
    }
  }

  if (route.component) {
    routeModule.addDeclaration(route.component);
    // serviceContainer.process();
  } else if (typeof route.loadComponent === 'function') {
    const routeLoadComponent = route.loadComponent;
    route.loadComponent = async () => {
      const mod =  await routeLoadComponent();
      const component = maybeUnwrapDefaultExport(await (mod instanceof Observable ? mod.toPromise() : mod));
      if (!component) {
        throw new Error('Missing component');
      }
      routeModule.addDeclaration(component);
      // serviceContainer.process();
      return component;
    };
  }

  return route;
}

export function createRouteConfig(routes: Routes): ApplicationConfig {
  return { providers: [provideRouter(routes)] };
}
